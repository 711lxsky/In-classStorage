指针储存的是数据的地址位置，通过指针指向就可以定位到内存地址
```C++
int v;  //假定地址位置为addr
int *p=&v;

//这样p的data段内容就是v的内存地址，即addr，相当于p=&v=addr，而指针指向的对象则是*p，它映射到了v的data段内容

cout<< (*p==v)?true:false; //true
```

```C++
//T*的值集是可存储T类型值的所有 合法地址 构成的集合，空指针类型字面值是0、nullptr
```

```C++
//假设T为任意类型
//&为取地址符
//*将操作数的值看作为地址去寻找数据
//这两个操作互逆
char c='a';
char *p=&c;

char c2=*p; //c2='a'
*p='6';     //c='6'

*(&c)==c; //true
&(*p)==p; //true
```

数组是**类型相同**，**连续存储**的**有序集合**，每个元素都可以用下标进行访问，对于类型T，声明$T[n]$就是由n个类型为T的元素构成的数组，元素下标从$0到n-1$。类型T除了void都可以，**二维数组是一维数组的一维数组，三维是二维的一维数组，以此类推**

```C++
//数组声明是一个麻烦事，因为情况多样，不尽相同
//同时声明
float v[3];        //v的类型为float[3]
int d2[10][4];     //d2的类型为(int[4])[10]

//不同时声明
typedef int T[4];
T d1;              //相当于int d1[4]
T d2[10];          //相当于int d2[10][4]

//声明的元素和初始化要有对应，不能超过声明的数目
int v1[4]={1,2,3,4};        //ok
char v2[6]={'a','b','c'};   //ok
//等价于v2[6]={'a','b','c',0,0,0};
//int v3[2]={1,2,3,0};      //这个是不行的，会报错，越界了

//也可以不在声明的时候用括号声明大小，可以通过初始列表中的元素个数来确定
int v1[]={1,2,3,4};    //v1类型为int[4]

//这个操作也可以在多位数组中实现，可以不给出 第一维 的元素个数，但是其它维都必须给出
int A[][2]={{1,2},{3,4},{5,6}};//定义数组A[3][2]
```

对于C++来说，使用vector会比使用数组要好用，还存在便于数学计算的$valarray<T>$

字符串的字面值是用**双引号**的一个**常量**，以'\0'结尾，可以用数组来表示和处理

数组和指针的效基本一致，所以可以进行转换
```C++
char v[]="who am I";
char *p=v;
strlen(p)==strlen(v); //true
```

加法和减法也可以应用于指针，效果是指针偏移
```C++
int v[10],i,j,*p=&v[4],*q;
q=p+3;
i=*q; //q=&v[7]
j=*p; //p=&v[4]

q=p-3;
i=*q; //q=&v[1]
j=*p; //p=&v[4]
```

两个指向相同数组元素的指针可以进行减法，获得的是偏移量（int）
```C++
int v[10],a[5],i,j,*p,*q;
p=&v[5];
q=&v[0];
i=p-q; //i=5
j=q-p; //j=-5

//但是跨数组相减就没有意义了，同时如果越界相减也会产生问题
j=p-&a[0];   //没意义
p=&v[10]-v;  //越界
```

编译器不会进行越界检查，所以要时刻注意
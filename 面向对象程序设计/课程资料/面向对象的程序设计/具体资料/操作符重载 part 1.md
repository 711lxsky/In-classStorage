重载操作符有基本的前提：
* 不能改变操作符的结构规则（包括语法结构、操作数个数、优先级、结合律等）
* 不能与其它类型用操作符表示的操作之间存在冲突（即在某一种特定表达式中，某个操作符应该有明确的，唯一的含义）

C++中不允许重载的操作符如下：
```C++
::      //作用域解析符
.       //成员运算符
.*      //成员运算符
?:      //三元操作符
sizeof  //取类的占有内存
typeid  //取类的id
```

C++不允许定义语言未定义的操作符，或者组合定义操作符，如：
```C++
$
**
```

操作符重载是**非静态成员函数**，或**非成员函数**，**operator+操作符**来表示完整的函数名，重载的基本例子：
```C++
class complex{
	double re,im;
public:
	complex(double r, double i);
	complex& operator+=(complex c){
		re+=c.re;im+=c.im;return *this;
	}  //重载
	complex operator*(complex c);
	
	operator double() const{
		return re;
	}//类型转换操作符，不能指定返回值类型，必定成员函数，没有参数，通常是const，可以隐式调用
};

//针对二元操作数
//非静态成员函数的重载只有一个参数，第一操作数默认为*this，第二操作数才是形参，类型不限
(b+c)==b.operator+(c); //true

//非成员函数需要两个参数，至少一个为自定义类型
operator+(a,b);

//针对一元操作数（注：int为占位符，用于和前缀做区分）
//非静态成员函数不需要任何参数，仍然把操作数默认为*this
//@aa
aa.operator@();
//aa@
aa.operator@(int);

//非成员函数需要一个参数，并且这个参数是自定义类型
//@aa
operator@(aa);
//aa@
operator@(aa,int);
```

* 重载操作符至少有一个操作数是**自定义类型**的
* 如果第一操作数为基本类型，则不能定义为成员函数
* 对于$=,[ \ ],(),$->这四个操作符，必须采用**非静态的成员函数**来重载，保证第一操作数一定是左值

friend(**友元**)，首先，如果去定义一个非静态成员函数，会有以下三个特征：
1. 可以调用class中定义的private成员
2. 函数在class的代码之中
3. 函数存在this指针
如果将这个函数定义为静态函数，则其还能实现前两种特征。
如果将函数定义为friend（类的友元），则这个函数只能有第一种特征。

一个友元可以是一个**全局函数**，也可以是一个**成员函数**，还能是一个**类**，友元破坏了类的封装和信息隐藏，所以要少用。友元的**最重要用处**就是直接获得类中的private数据，破坏封装。

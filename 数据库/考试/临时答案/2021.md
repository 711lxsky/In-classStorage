根据提供的关系模式和要求，以下是每个问题的详细解答。

### 1. 创建医生表

```sql
CREATE TABLE 医生 (
    员工号 INT PRIMARY KEY,
    姓名 VARCHAR(100),
    科室号 INT,
    岗位等级 INT CHECK (岗位等级 BETWEEN 1 AND 10),
    电话 VARCHAR(20),
    基本工资 DECIMAL(10, 2),
    FOREIGN KEY (科室号) REFERENCES 科室(科室号)
);
```

### 2. 关系代数表达式实现查询

查询编号“10071”的病人于 2021 年 12 月 16 日的就诊医生员工号、姓名、电话：

\[ \pi_{员工号, 姓名, 电话} (\sigma_{病人编号=10071 \land 就诊时间='2021-12-16'} (医生 \bowtie 医疗)) \]

### 3. 元组演算表达式实现查询

查询编号“10071”的病人于 2021 年 12 月 16 日的就诊医生员工号、姓名、电话：

\[ \{ t.员工号, t.姓名, t.电话 \mid t \in 医生 \land \exists s \in 医疗 (s.员工号 = t.员工号 \land s.病人编号 = 10071 \land s.就诊时间 = '2021-12-16') \} \]

### 4. SQL 实现查询

```sql
SELECT 医生.员工号, 医生.姓名, 医生.电话
FROM 医生
JOIN 医疗 ON 医生.员工号 = 医疗.员工号
WHERE 医疗.病人编号 = 10071 AND DATE(医疗.就诊时间) = '2021-12-16';
```

### 5. 给岗位级别 5 级以下且基本工资低于 2000 元的医生涨工资 200 元

```sql
UPDATE 医生
SET 基本工资 = 基本工资 + 200
WHERE 岗位等级 < 5 AND 基本工资 < 2000;
```

### 6. 查询 2021 年就诊病历中包含“新冠”的就诊情况

```sql
SELECT 医疗.科室号, 科室.科室名, SUM(医疗.费用) AS 总费用
FROM 医疗
JOIN 科室 ON 医疗.科室号 = 科室.科室号
WHERE YEAR(医疗.就诊时间) = 2021 AND 医疗.就诊病历 LIKE '%新冠%'
GROUP BY 医疗.科室号, 科室.科室名
ORDER BY 医疗.就诊时间 ASC;
```

### 7. 删除就诊时间 2015 年 12 月 31 日以前的，总费用低于 1000 元的就诊记录

```sql
DELETE FROM 医疗
WHERE DATE(就诊时间) < '2015-12-31' AND 费用 < 1000;
```

### 8. 创建一个出院单视图

```sql
CREATE VIEW 出院单 AS
SELECT 
    医疗.病人编号, 
    病人.病人姓名, 
    病人.身份证号码, 
    医疗.就诊时间, 
    科室.科室名 AS 就诊科室, 
    医疗.就诊病历, 
    医疗.费用 AS 费用总计
FROM 医疗
JOIN 病人 ON 医疗.病人编号 = 病人.病人编号
JOIN 科室 ON 医疗.科室号 = 科室.科室号;
```

以上是每个问题的详细解答，涵盖了关系代数、元组演算以及 SQL 查询的实现。


------

要找到给定函数依赖集 \( F \) 的极小函数依赖集，我们需要遵循以下步骤：

1. **消除冗余的函数依赖**：检查每个函数依赖是否可以由其他函数依赖推导出来。
2. **消除冗余的属性**：检查每个函数依赖中的决定因子和依赖因子是否可以简化。

给定的函数依赖集 \( F = \{A \rightarrow BC, AD \rightarrow E, B \rightarrow D, A \rightarrow D\} \)。

### 步骤 1: 消除冗余的函数依赖

#### 检查 \( A \rightarrow D \)
- 已知 \( A \rightarrow BC \)，因此 \( A \rightarrow C \) 和 \( A \rightarrow B \)。
- 由于 \( B \rightarrow D \)，所以 \( A \rightarrow B \rightarrow D \)。
- 因此，\( A \rightarrow D \) 可以由 \( A \rightarrow BC \) 和 \( B \rightarrow D \) 推导出来，是冗余的。

更新后的函数依赖集：
\[ F' = \{A \rightarrow BC, AD \rightarrow E, B \rightarrow D\} \]

#### 检查 \( AD \rightarrow E \)
- 目前没有其他函数依赖可以直接推导出 \( AD \rightarrow E \)，因此保留。

#### 检查 \( B \rightarrow D \)
- 目前没有其他函数依赖可以直接推导出 \( B \rightarrow D \)，因此保留。

### 步骤 2: 消除冗余的属性

#### 检查 \( A \rightarrow BC \)
- 尝试分解 \( A \rightarrow BC \)：
  - \( A \rightarrow B \)：已知 \( A \rightarrow BC \)，因此 \( A \rightarrow B \) 成立。
  - \( A \rightarrow C \)：已知 \( A \rightarrow BC \)，因此 \( A \rightarrow C \) 成立。
- 因此，\( A \rightarrow BC \) 可以分解为 \( A \rightarrow B \) 和 \( A \rightarrow C \)。

更新后的函数依赖集：
\[ F'' = \{A \rightarrow B, A \rightarrow C, AD \rightarrow E, B \rightarrow D\} \]

### 最终极小函数依赖集
经过上述步骤，最终得到的极小函数依赖集为：
\[ F_{min} = \{A \rightarrow B, A \rightarrow C, AD \rightarrow E, B \rightarrow D\} \]

### 主要步骤总结
1. 消除冗余的函数依赖：
   - 发现 \( A \rightarrow D \) 是冗余的，因为可以通过 \( A \rightarrow BC \) 和 \( B \rightarrow D \) 推导出来。
2. 消除冗余的属性：
   - 将 \( A \rightarrow BC \) 分解为 \( A \rightarrow B \) 和 \( A \rightarrow C \)。

最终得到的极小函数依赖集为：
\[ F_{min} = \{A \rightarrow B, A \rightarrow C, AD \rightarrow E, B \rightarrow D\} \]

------

要判断分解 \( \rho = \{R1(AB), R2(AC)\} \) 是否具有无损连接性，我们需要按照以下步骤进行：

### 步骤 1: 确定原关系的函数依赖集
给定的关系模式 \( R(A, B, C, D) \) 的函数依赖集为：
\[ F = \{AC \rightarrow B, B \rightarrow C\} \]

### 步骤 2: 计算每个子关系的闭包
我们需要计算每个子关系的属性闭包。

#### 子关系 \( R1(AB) \)
- 属性集合：\( \{A, B\} \)
- 应用函数依赖 \( AC \rightarrow B \) 和 \( B \rightarrow C \)：
  - 由于 \( R1 \) 中没有 \( C \)，无法应用 \( AC \rightarrow B \)。
  - 由于 \( R1 \) 中有 \( B \)，可以应用 \( B \rightarrow C \)，但 \( C \) 不在 \( R1 \) 中。
- 因此，\( R1 \) 的闭包为 \( \{A, B\} \)。

#### 子关系 \( R2(AC) \)
- 属性集合：\( \{A, C\} \)
- 应用函数依赖 \( AC \rightarrow B \) 和 \( B \rightarrow C \)：
  - 可以应用 \( AC \rightarrow B \)，因此 \( B \) 可以加入到闭包中。
  - 由于 \( B \rightarrow C \)，且 \( C \) 已经在 \( R2 \) 中，不需要进一步扩展。
- 因此，\( R2 \) 的闭包为 \( \{A, C, B\} \)。

### 步骤 3: 判断是否具有无损连接性
为了判断分解是否具有无损连接性，我们需要检查是否存在公共属性，并且这些公共属性是否能够唯一确定其他属性。

#### 公共属性
- \( R1 \) 和 \( R2 \) 的公共属性是 \( A \)。

#### 检查公共属性是否能唯一确定其他属性
- 在 \( R1 \) 中，只有 \( A \) 和 \( B \)，无法通过 \( A \) 确定 \( C \)。
- 在 \( R2 \) 中，可以通过 \( AC \rightarrow B \) 确定 \( B \)，但 \( R1 \) 中没有 \( C \)。

### 结论
- 由于 \( R1 \) 和 \( R2 \) 的公共属性 \( A \) 不能唯一确定所有其他属性（特别是 \( C \)），因此该分解不具有无损连接性。

### 总结
分解 \( \rho = \{R1(AB), R2(AC)\} \) 不具有无损连接性，因为公共属性 \( A \) 不能唯一确定所有其他属性。

------

### 1. ER 图设计

根据需求描述，我们可以设计以下实体和联系：

- **孵化公司** (HatchCompany)
  - 属性: 公司代码, 公司名称, 法人代表名称, 注册地址, 电话
- **创业公司** (StartupCompany)
  - 属性: 公司代码, 公司名称, 电话
- **员工** (Employee)
  - 属性: 工号, 身份证号, 姓名, 性别, 手机号
- **投资方** (Investor)
  - 属性: 投资方编号, 投资方名称, 电话
- **创业项目合作关系** (ProjectCooperation)
  - 属性: 开始日期, 结束日期
  - 联系属性: 创业项目编号
- **投资关系** (Investment)
  - 属性: 投资金额, 投资日期

#### 实体之间的联系：
- **孵化公司** 和 **创业公司** 之间通过 **创业项目合作关系** 连接。
- **创业项目合作关系** 中包含一个指定的 **员工**。
- **创业项目合作关系** 可以接受多个 **投资方** 的投资。

### 2. 完整的 ER 图

以下是完整的 ER 图（使用中文名称）：

```plaintext
+------------------+       +------------------+       +------------------+
|   孵化公司       |-------|   创业公司       |-------|   创业项目合作关系 |
+------------------+       +------------------+       +------------------+
| 公司代码         |       | 公司代码         |       | 开始日期         |
| 公司名称         |       | 公司名称         |       | 结束日期         |
| 法人代表名称     |       | 电话             |       | 创业项目编号     |
| 注册地址         |       +------------------+       +------------------+
| 电话             |
+------------------+
```

```plaintext
+------------------+       +------------------+       +------------------+
|   员工           |-------|   创业项目合作关系 |-------|   投资方         |
+------------------+       +------------------+       +------------------+
| 工号             |       | 开始日期         |       | 投资方编号       |
| 身份证号         |       | 结束日期         |       | 投资方名称       |
| 姓名             |       | 创业项目编号     |       | 电话             |
| 性别             |       +------------------+       +------------------+
| 手机号           |
+------------------+
```

### 3. 关系模式转换

#### 1. 孵化公司 (HatchCompany)
- **属性**: 公司代码, 公司名称, 法人代表名称, 注册地址, 电话
- **主键**: 公司代码

#### 2. 创业公司 (StartupCompany)
- **属性**: 公司代码, 公司名称, 电话
- **主键**: 公司代码

#### 3. 员工 (Employee)
- **属性**: 工号, 身份证号, 姓名, 性别, 手机号
- **主键**: 工号

#### 4. 投资方 (Investor)
- **属性**: 投资方编号, 投资方名称, 电话
- **主键**: 投资方编号

#### 5. 创业项目合作关系 (ProjectCooperation)
- **属性**: 开始日期, 结束日期, 创业项目编号, 指定员工工号, 孵化公司代码, 创业公司代码
- **主键**: 创业项目编号
- **外键**: 指定员工工号 (参照 Employee), 孵化公司代码 (参照 HatchCompany), 创业公司代码 (参照 StartupCompany)

#### 6. 投资关系 (Investment)
- **属性**: 投资金额, 投资日期, 投资方编号, 创业项目编号
- **主键**: (投资方编号, 创业项目编号)
- **外键**: 投资方编号 (参照 Investor), 创业项目编号 (参照 ProjectCooperation)

### 4. 函数依赖集

#### 孵化公司 (HatchCompany)
- 公司代码 → 公司名称, 法人代表名称, 注册地址, 电话

#### 创业公司 (StartupCompany)
- 公司代码 → 公司名称, 电话

#### 员工 (Employee)
- 工号 → 身份证号, 姓名, 性别, 手机号

#### 投资方 (Investor)
- 投资方编号 → 投资方名称, 电话

#### 创业项目合作关系 (ProjectCooperation)
- 创业项目编号 → 开始日期, 结束日期, 指定员工工号, 孵化公司代码, 创业公司代码

#### 投资关系 (Investment)
- (投资方编号, 创业项目编号) → 投资金额, 投资日期

### 总结
以上是根据需求描述设计的数据库模型，包括 ER 图和关系模式，并给出了每个关系模式的函数依赖集。 
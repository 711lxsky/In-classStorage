为了建立所描述的关系数据库，首先我们定义各实体的关系模式，并分析函数依赖、候选码、外部码以及范式级别。接下来，我们将按照题目的要求进行分析。

### 学生(Student)

- **关系模式**：学生(学号, 姓名, 出生日期, 系名, 班号, 宿舍区)
  
  - **极小函数依赖集**：
    - 学号 → 姓名, 出生日期, 系名, 班号, 宿舍区
    - 班号 → 系名 (因为每个班都属于一个系)
  - **是否存在传递函数依赖**：否
  - **函数依赖类型**：学号 → 其他属性是完全函数依赖
  - **候选码**：学号
  - **外部码**：班号
  - **范式级别**：第三范式（3NF），因为每个非主属性都只直接依赖于候选码

### 班级(Class)

- **关系模式**：班级(班号, 专业名, 系名, 人数, 入校年份)
  
  - **极小函数依赖集**：
    - 班号 → 专业名, 系名, 人数, 入校年份
  - **是否存在传递函数依赖**：否
  - **函数依赖类型**：班号 → 其他属性是完全函数依赖
  - **候选码**：班号
  - **外部码**：系名
  - **范式级别**：3NF

### 系(Department)

- **关系模式**：系(系名, 系号, 系办公地点, 人数)
  
  - **极小函数依赖集**：
    - 系名 → 系号, 系办公地点, 人数
    - 系号 → 系名, 系办公地点, 人数
  - **是否存在传递函数依赖**：否
  - **函数依赖类型**：系名和系号都是候选码，它们对其他属性是完全函数依赖
  - **候选码**：系名, 系号
  - **外部码**：无
  - **范式级别**：3NF

### 学会(Association)

- **关系模式**：学会(学会名, 成立年份, 办公地点, 人数)
  
  - **极小函数依赖集**：
    - 学会名 → 成立年份, 办公地点, 人数
  - **是否存在传递函数依赖**：否
  - **函数依赖类型**：学会名 → 其他属性是完全函数依赖
  - **候选码**：学会名
  - **外部码**：无
  - **范式级别**：3NF

### 学生参加学会(Student_Association)

- **关系模式**：学生参加学会(学号, 学会名, 入会年份)
  
  - **极小函数依赖集**：
    - 学号, 学会名 → 入会年份
  - **是否存在传递函数依赖**：否
  - **函数依赖类型**：学号, 学会名 → 入会年份是完全函数依赖
  - **候选码**：学号 + 学会名
  - **外部码**：学号, 学会名
  - **范式级别**：3NF

### 全码存在的讨论

在这些关系模式中，全码的存在性质通常指一个关系模式的所有属性都参与到候选码中。根据上述分析，大多数定义的关系模式都具有明确的候选码，这些候选码通常只包含少数几个属性，而不是所有属性。因此，这些模式中并没有全码的情况，除了特殊的情况需要进一步讨论，如学生参加学会(Student_Association)模式。

对于学生参加学会(Student_Association)这一关系模式，其候选码是由两个属性组成的复合码：学号和学会名。这两个属性一起唯一标识了表中的每条记录，但它们并不构成全码，因为全码要求表中的所有属性都是候选码的一部分，而在这个模式中，入会年份并不是候选码的一部分。

因此，可以确定的是，在这些关系模式中不存在全码情况。每个关系模式都有明确的候选码用于唯一标识记录，而这些候选码通常只包括部分属性，不是所有属性。这样的设计有助于减少数据冗余，提高数据库的整体效率和维护性。

总结来说，这些关系模式都设计得符合第三范式（3NF），避免了传递依赖，确保了数据的一致性和可维护性。每个模式的候选码都精心选择以满足实体的唯一标识需求，而没有出现全码的情况。

--------------

让我们逐一分析这些结论的正确性，并对错误的结论给出反例。

### （1）任何一个二目关系是属于2NF的。

- **正确**。二目关系（二元关系）意味着该关系模式只包含两个属性。2NF要求数据库表中不存在部分函数依赖，即非主属性完全函数依赖于候选键。在只有两个属性的情况下，如果存在函数依赖，那么这个函数依赖必然是完全函数依赖，因此任何二目关系自然满足2NF的要求。

### （2）任何一个二目关系是属于3NF的。

- **正确**。3NF要求一个关系模式要先满足2NF，且不存在传递依赖（非主属性不依赖于其他非主属性）。对于只有两个属性的关系模式，如果存在函数依赖，由于只有一个可能的候选键，不存在非候选键的属性，因此也不存在能导致传递依赖的情况。因此，任何二目关系也满足3NF的要求。

### （3）任何一个二目关系是属于BCNF的。

- **正确**。BCNF是3NF的加强版，要求对于任何非平凡函数依赖 \(X \rightarrow Y\)，\(X\) 必须包含一个候选键。在只有两个属性的情况下，如果存在函数依赖，那么函数依赖的左侧（即 \(X\)）要么是整个关系的候选键，要么是其中一个属性，这满足BCNF的定义。因此，任何二目关系也满足BCNF的要求。

### （4）当且仅当函数依赖A→B在R上成立，关系R(A, B, C)等于其投影R1(A, B)和R2(A, C)的连接。

- **错误**。这个结论忽略了可能存在的其他函数依赖，如 \(C \rightarrow A\)，\(C \rightarrow B\)，或者 \(A \rightarrow C\)。只有当所有的函数依赖都被考虑，且关系R没有更多的信息比这两个投影的自然连接提供的时，这个结论才成立。反例：如果存在函数依赖 \(C \rightarrow A\)，那么仅通过R1和R2的连接不能完全恢复R的所有信息。

### （5）若R.A→R.B，R.B→R.C，则R.A→R.C。

- **正确**。这是函数依赖的传递规则，如果 \(A \rightarrow B\) 和 \(B \rightarrow C\)，那么 \(A \rightarrow C\)。

### （6）若R.A→R.B，R.A→R.C，则R.A→R.(B, C)。

- **正确**。这是函数依赖的合并规则，如果 \(A \rightarrow B\) 和 \(A \rightarrow C\)，则 \(A \rightarrow B, C\)。

### （7）若R.B→R.A，R.C→R.A，则R.(B, C)→R.A。

- **错误**。这个结论假设了两个不同的属性（或属性组）可以独立地决定另一个属性，从而推断出它们合并起来也能决定这个属性。然而，这不满足函数依赖的定义。反例：考虑一个关系，其中B和C是两个不同的属性，它们分别可以决定A，但是A的值可能依赖于B和C的特定组合，这样B和C单独决定A并不意味着它们组合在一起也能决定A。

### （8）若R.(B, C)→R.A，则R.B→R.A，R.C→R.A。

- **错误**。这个结论假设了如果一个属性组合可以决定另一个属性，那么组合中的每个单独属性也能独立决定那个属性。这是不正确的。反例：设想一个关系模式，其中 \(B, C\) 联合起来唯一地决定了 \(A\)（例如，\(B, C \rightarrow A\)），但是 \(B\) 单独或 \(C\) 单独并不能决定 \(A\)。例如，考虑一个简单的数据库表，记录了学生参加的竞赛团队和获得的奖项，其中团队名称和年份（B和C）联合起来可以决定获得的奖项（A），但是仅知道团队名称或年份是无法确定奖项的。

总结：

- **正确的结论**：（1）、（2）、（3）、（5）、（6）。
- **错误的结论**：（4）、（7）、（8），并且我已经提供了反例来说明它们为什么是错误的。

这些练习展示了数据库理论中函数依赖和范式理论的一些基本概念，以及它们在设计和理解关系数据库结构中的重要性。理解这些原理有助于设计更高效、更一致、更少冗余的数据库系统。

-----------

要回答这些问题，我们需要逐步分析给出的信息和进行一些计算。

### （1）判断分解ρ是否具有无损连接性

无损连接性的判断可以通过使用投影-连接性质（也称为无损连接检测算法）来完成。一个分解ρ={R1, R2}对于关系R是无损的，如果存在一个公共属性集X，使得X是R1和R2的公共属性集，并且X→R1中的属性集或X→R2中的属性集是在原关系R上的函数依赖集F+的一部分。

对于ρ={R1(ABD), R2(ACE)}：

- 公共属性集是A。
- 查看给定的函数依赖集F={A→BC, BCD→E, B→D, A→D, E→A}，我们可以看到A→D是F的一部分，A可以决定R1中的全部属性，或者A→A（显然A可以决定自己），A可以决定R2中的属性。

因此，我们可以说这个分解具有无损连接性，因为可以通过A来保证连接后不会产生额外的元组。

### （2）计算分解后的关系模式R1和R2的函数依赖集，并判断分解ρ是否保持函数依赖

首先，我们需要找出哪些函数依赖可以完全应用于R1(ABD)和R2(ACE)。

- 对于R1(ABD)，我们可以直接应用的函数依赖有：
  - A→D（直接给出）
  - B→D（直接给出）
- 对于R2(ACE)，我们可以直接应用的函数依赖有：
  - E→A（直接给出）

现在，我们来判断分解ρ是否保持函数依赖。一个分解ρ保持函数依赖，如果原关系R上的每个函数依赖都可以由分解后的关系模式上的函数依赖集推导出来。

- 在R1中，A→B和A→D可以部分保持，因为B不在R1中。
- 在R2中，A→C可以保持，E→A也可以保持。
- BCD→E和A→BC这两个函数依赖在分解中无法直接体现，因为它们涉及到的属性被分散到了R1和R2中。

因此，分解ρ部分保持函数依赖，但不是完全保持。

### （3）分析各关系模式（即R, R1, R2）的范式级别

- **原关系模式R(ABCDE)**：
  - 给定的F中，E→A表明存在一个非主属性决定了候选键，这违反了BCNF的定义。
  - 但是，由于A可以决定BCD，而BCD又可以决定E，整个关系可以被A的值唯一确定，这符合3NF的要求（如果我们假设A是候选键）。因此，R至少在3NF中。

- **关系模式R1(ABD)**：
  - 在R1中，A→D，B→D都符合2NF和3NF的要求，因为D是由它们的一个部分（A或B）完全函数依赖的。
  - 没有显示违反BCNF的证据，因为我们没有足够的信息确定候选键。但是，基于给定的信息，R1可能达到3NF或BCNF。

- **关系模式R2(ACE)**：
  - 在R2中，E→A符合2NF和3NF的要求，因为A是由E完全函数依赖的。
  - 同样，没有显示违反BCNF的证据，R2可能达到3NF或BCNF。

原关系R的基础上，我们可以进一步细化范式级别的分析：

- **原关系模式R(ABCDE)的范式级别**：虽然我们初步判断R至少在3NF中，但具体是否满足BCNF取决于候选键的具体情况。由于E→A存在，这意味着非主属性E能够决定另一个属性A，这在BCNF中是不允许的（除非E包含候选键）。因此，如果A是一个候选键，这个关系模式违反了BCNF的条件。由于我们没有足够的信息来识别所有的候选键，我们不能准确地说R是否满足BCNF，但可以确定的是，它至少满足3NF。

- **关系模式R1(ABD)的范式级别**：根据R1中的函数依赖，A或B到D的依赖关系表明，如果A或B是候选键，那么R1可能满足BCNF，因为这些依赖关系都是键依赖。但是，我们需要更多的信息来确定是否存在其他候选键或函数依赖，这可能影响范式级别的判断。基于现有信息，我们假设R1至少满足3NF。

- **关系模式R2(ACE)的范式级别**：考虑到E→A的依赖，如果E是候选键，那么这个模式满足BCNF。没有其他的函数依赖指出非键属性决定键属性的情况，所以R2很可能达到BCNF。同样，我们需要更多的信息来做出最终判断，但至少可以说它满足3NF。

### 综合分析

在数据库设计中，保持函数依赖是分解过程中的一个重要考虑因素，因为它影响到数据的完整性。虽然分解ρ在某种程度上保持了函数依赖，但它并不完全保持原有的所有函数依赖，这可能导致一些数据完整性约束在分解后的模式中无法直接体现。

无损连接性是另一个重要的考虑因素，它确保了分解操作不会因为连接操作而丢失信息。在这个例子中，分解ρ具有无损连接性，这是一个积极的方面。

最后，关于范式级别，原关系R由于E→A的存在，可能不满足BCNF，但至少满足3NF。分解后的关系模式R1和R2在给定的信息下，可能达到3NF甚至BCNF，但具体情况取决于更详细的候选键和函数依赖分析。

在实际的数据库设计过程中，达到3NF通常被认为是足够的，因为它能够解决大多数的数据冗余问题，而BCNF则提供了更严格的约束，以避免更新异常。每次分解都需要仔细考虑，以确保不会损失信息或破坏数据的完整性。